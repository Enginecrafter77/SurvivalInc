package enginecrafter77.survivalinc.stats.effect.item;

import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.Type;

import enginecrafter77.survivalinc.stats.StatCapability;
import enginecrafter77.survivalinc.util.ForgeASMInjector;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraftforge.fml.common.eventhandler.Event;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

public class ItemSituationContainer {
	
	private static final String DESC_CONTAINER = Type.getDescriptor(ItemSituationContainer.class);
	
	private final Map<Class<? extends Event>, List<ItemSituation<?>>> effectmap;
	
	public ItemSituationContainer()
	{
		this.effectmap = new HashMap<Class<? extends Event>, List<ItemSituation<?>>>();
	}
	
	public void trigger(Event event)
	{
		List<ItemSituation<?>> situations = this.effectmap.get(event.getClass());
		if(situations == null) return;
		
		situations.forEach((ItemSituation<?> effect) -> applyTo(effect, event));
	}
	
	public void register(Iterable<ItemSituation<?>> situations)
	{
		for(ItemSituation<?> situation : situations) this.register(situation);
	}
	
	public void register(ItemSituation<?> situation)
	{
		Class<? extends Event> typeclass = situation.getEventClass();
		List<ItemSituation<?>> situations = this.effectmap.get(typeclass);
		if(situations == null)
		{
			situations = new ArrayList<ItemSituation<?>>();
			this.effectmap.put(typeclass, situations);
		}
		situations.add(situation);
	}
	
	private static <TYPE extends Event> void applyTo(ItemSituation<TYPE> situation, Event event)
	{
		Class<TYPE> specclass = situation.getEventClass();
		if(!specclass.isInstance(event)) return;
		
		TYPE specevent = specclass.cast(event);
		if(situation.isTriggeredBy(specevent))
		{
			EntityPlayer player = situation.getPlayer(specevent);
			situation.apply(player.getCapability(StatCapability.target, null));
		}
	}
	
	public Set<Class<? extends Event>> getCapturedEvents()
	{
		return this.effectmap.keySet();
	}
	
	/**
	 * Creates a virtual class using ASM to handle each defined event.
	 * The resultant class has 1 constructor, which takes 1 parameter:
	 * the {@link ItemSituationContainer} instance. The class has then
	 * n methods, 1 for each event the ItemSituationContainer uses. Each
	 * of these methods is annotated by {@link SubscribeEvent}, which means
	 * this resultant object is meant to be used by {@link net.minecraftforge.fml.common.eventhandler.EventBus#register(Object) EventBus.register()}
	 * Each of these methods call {@link ItemSituationContainer#trigger(Event)},
	 * with the received event as the parameter. In order for the register
	 * method to work, the classes need to be defined inside the {@link net.minecraftforge.fml.common.eventhandler.ASMEventHandler#LOADER}
	 * class loader. In order to make this possible, {@link ForgeASMInjector} is used
	 * to define a class using the generated bytecode, thus making the class "visible"
	 * for Forge's ASMEventHandler.
	 * @return An event handler object for registration in {@link net.minecraftforge.fml.common.eventhandler.EventBus#register(Object) EventBus.register()}
	 */
	public Object createEventHandler()
	{
		Collection<Class<? extends Event>> events = this.getCapturedEvents();
		String name = Type.getInternalName(this.getClass()) + "$TriggerEventHandler";
		
		ClassWriter writer = new ClassWriter(0);
		writer.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, name, null, "java/lang/Object", null);
		writer.visitSource("<dynamic>:ItemSituationContainer.java", null);
		
		// Add container field
		writer.visitField(Opcodes.ACC_PROTECTED + Opcodes.ACC_FINAL, "container", DESC_CONTAINER, null, null).visitEnd();
		
		MethodVisitor constructor = writer.visitMethod(Opcodes.ACC_PUBLIC, "<init>", "(" + DESC_CONTAINER + ")V", null, null);
		constructor.visitCode();
		
		// super();
		constructor.visitVarInsn(Opcodes.ALOAD, 0);
		constructor.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/Object", "<init>", "()V", false);
		
		// this.container = container
		constructor.visitVarInsn(Opcodes.ALOAD, 0);
		constructor.visitVarInsn(Opcodes.ALOAD, 1);
		constructor.visitFieldInsn(Opcodes.PUTFIELD, name, "container", DESC_CONTAINER);
		constructor.visitInsn(Opcodes.RETURN);
		constructor.visitMaxs(2, 2);
		constructor.visitEnd();
		
		for(Class<? extends Event> event : events)
		{
			MethodVisitor handler = writer.visitMethod(Opcodes.ACC_PUBLIC, "delegateEvent", "(" + Type.getDescriptor(event) + ")V", null, null);
			handler.visitAnnotation(Type.getDescriptor(SubscribeEvent.class), true).visitEnd(); // Annotate with SubscribeEvent
			handler.visitCode();
			handler.visitVarInsn(Opcodes.ALOAD, 0);
			handler.visitFieldInsn(Opcodes.GETFIELD, name, "container", DESC_CONTAINER);
			handler.visitVarInsn(Opcodes.ALOAD, 1);
			handler.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(ItemSituationContainer.class), "trigger", "(" + Type.getDescriptor(Event.class) + ")V", false);
			handler.visitInsn(Opcodes.RETURN);
			handler.visitMaxs(2, 2);
			handler.visitEnd();
		}
		
		writer.visitEnd();
		
		try
		{
			byte[] buffer = writer.toByteArray();
			Class<?> handlerclass = ForgeASMInjector.getInstance().injectClass(null, buffer);
			Constructor<?> handlerconst = handlerclass.getConstructor(ItemSituationContainer.class);
			return handlerconst.newInstance(this);
		}
		catch(ReflectiveOperationException exc)
		{
			throw new RuntimeException("Exception generating ASM Handler for " + events.toString(), exc);
		}
	}
}
